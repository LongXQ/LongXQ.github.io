多核处理器的支持：缓存一致性
=============================

.. graphviz::

   digraph atomic1 {
       subgraph clusterA {
           A1 [label="Core 1" shape="box"]
           B1 [label="寄存器" shape="box"]
           C1 [label="缓存" shape="box"]
           A1 -> B1 -> C1
       }
       subgraph clusterB {
           A2 [label="Core 2" shape="box"]
           B2 [label="寄存器" shape="box"]
           C2 [label="缓存" shape="box"]
           A2 -> B2 -> C2
       }
  
        D [label="内存" shape="box"]
       
       C1 -> D
       C2 -> D
   }

缓存一致性协议
----------------

缓存和寄存器都是每个cpu核私有的，内存是共享的。对于同一个内存位置的数据，可能在不同的核中都有缓存。如果一个核写数据更新了
缓存，那么此时就会出现对于同一份数据，不同核看到的数据不一致，这就需要处理器提供缓存一致性协议，保证数据在不同核核内存中的一致性。

最出名的就是Intel 的MESI协议，MESI协议保证了每个缓存中使用的共享变量的副本是一致的。
它核心的思想是：当一个核写数据时，如果发现操作的变量是共享变量，即在其他核中也存在该变量的副本，会发出信号通知其他核将该变量的缓存行置为无效状态，
因此当其他核需要读取这个变量时，发现自己缓存中缓存该变量的缓存行是无效的，那么它就会从内存重新读取。

所以处理器提供的缓存一致性协议能够保证缓存之间数据的正确性，不同线程看到的数据视图是一致的。

可见性问题
------------------

可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。

举个简单的例子，看下面这段代码：

.. code-block:: c

    //线程1执行的代码
    int i = 0;
    i = 10;
 
    //线程2执行的代码
    j = i;

假若执行线程1和执行线程2分别在不同核上执行。由上面的分析可知，当线程1执行
*i=10*
这句时，会先把i的初始值加载到当前核的高速缓存中，然后赋值为10，
那么高速缓存当中i的值变为10了，但是没有立即写入到主存当中，
因为此时i只是该核的缓存中有，其他核还没有，一致性协议也不能保证缓存会立即会写到内存中去。

此时线程2执行
*j=i*，
它会先去主存读取i的值并加载到当前核的缓存当中，注意此时内存当中i的值还是0，那么就会使得j的值为0，而不是10.

这就出现了不一致问题，线程1对变量i修改了之后，线程2没有立即看到线程1修改的值。
也就是线程1修改的值对线程2不可见，所以叫可见性问题。

所以处理器除了需要提供缓存一致性协议保证不同核中缓存数据一致之外，还需要提供机制给上层应用，
能够立即把数据从缓存中写到内存中去。

对上层应用来讲，处理器提供了以下几种机制：

1. LOCK指令会把前面的所有写缓存数据写到内存中，如果其他核中有同一个内存的缓存，则会使其无效，下次读取的时候回重新从内存中读。
   除此之外，LOCK指令还能避免多个核同时写缓存。LOCK指令会锁住总线，只有执行该LOCK指令的线程能够写缓存，并把数据写会到内存中，
   所以到该指令执行完后，数据已经写会内存中去了。因为锁住了总线，所以有性能开销。
2. 串行指令。和LOCK指令一样，在执行下一条指令前，也会等待前面指令执行完毕（内存屏障），并且所有写缓存写回内存中去，避免了可见性问题。
3. 屏障指令

**参考资料**

`Intel® 64 and IA-32 Architectures Software Developer's Manual Volume 3A: System Programming Guide, Part 1 <https://software.intel.com/en-us/download/intel-64-and-ia-32-architectures-sdm-volume-3a-system-programming-guide-part-1>`_
