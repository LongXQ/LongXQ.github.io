<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Linux用户id · oooo</title><meta name="description" content="Linux用户id - 龙雄球"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://longxq.github.io/atom.xml" title="oooo"></head><body><div class="wrap"><header><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/LongXQ" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xm" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">Linux用户id</h1><div class="post-info">Jul 7, 2018</div><div class="post-content"><p>一个进程都有实际用户ID，有效用户ID和保存的设置用户ID。其中实际用户ID和有效用户ID都可以通过下面的函数得到或设置。  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;  </span></span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">setuid</span><span class="params">(<span class="keyword">uid_t</span> uid)</span>    <span class="comment">//设置进程的实际用户ID和有效用户ID  </span></span></span><br><span class="line"><span class="function">    <span class="keyword">int</span> <span class="title">getuid</span><span class="params">(<span class="keyword">void</span>)</span>    <span class="comment">//得到进程的实际用户ID  </span></span></span><br><span class="line"><span class="function">    <span class="keyword">int</span> <span class="title">seteuid</span><span class="params">(<span class="keyword">uid_t</span> uid)</span>    <span class="comment">//设置进程的有效用户ID  </span></span></span><br><span class="line"><span class="function">    <span class="keyword">int</span> <span class="title">geteuid</span><span class="params">(<span class="keyword">void</span>)</span>    <span class="comment">//得到进程的有效用户ID  </span></span></span><br><span class="line"> ```     </span><br><span class="line">  </span><br><span class="line">&lt;!-- more --&gt;</span><br><span class="line">这些ID的作用其实控制进程访问权限的，比如一些资源只能给超级用户访问，那么如果具有一般用户权限的进程就没有资格访问。  </span><br><span class="line">那他们在进程的初始化过程中是怎么设置的呢？  </span><br><span class="line">当一个程序文件被执行时，进程的实际用户ID和有效用户ID都被设置成执行这个程序文件的用户ID，而不管这个程序的文件的所有者是谁。如果这个程序文件的设置用户位被设置了，那么有效用户ID被初始化为这个程序文件的所有者用户ID。而对于进程的保存的设置用户ID则是复制进程的有效用户ID。  </span><br><span class="line">在控制进程的访问控制权限是通过有进程的用户ID来判断的。  </span><br><span class="line">为什么进程要有有效用户ID和保存的设置用户ID呢？  </span><br><span class="line">进程为什么这么麻烦要设置这么多个ID呢，为什么不直接使用实际用户ID来控制访问权限呢，毕竟有效用户ID代表着实际执行这个程序的用户，理应以实际用户ID为准的。  </span><br><span class="line">之所以还要有有效的用户ID是因为，进程有可能在执行过程中，访问权限会发生变化，比如有可能当前进程只需要具有普通用户的权限就可以了，但是过会进程需要超级用户权限才能继续执行。所以才有了有效用户ID。而这样的程序文件如果要更改访问权限，必须程序文件的设置用户位被设置了才能更改。  </span><br><span class="line">最后对于保存的设置用户ID的作用是用来恢复有效用户ID到初始状态的，毕竟有效用户ID既然能改变，那就有可能恢复到改变前的ID，而恢复肯定依照某个东西来恢复才行，不能乱来，这个依照物就是进程保存的设置用户ID。  </span><br><span class="line">下面以例子说明：  </span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">    <span class="comment">// repid.c  </span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;  </span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;  </span></span></span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        <span class="keyword">uid_t</span> uid=getuid();  </span><br><span class="line">    	<span class="keyword">uid_t</span> euid=geteuid();  </span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">"uid=%d\n"</span>,uid);  </span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">"euid=%d\n"</span>,euid);  </span><br><span class="line">    	<span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line"> ```     </span><br><span class="line">  </span><br><span class="line">上面这个程序就是打印进程的实际用户ID和有效用户ID的。假设当前系统有两个用户root和user1，root用户ID为<span class="number">0</span>，user1用户ID为<span class="number">1000.</span>在root下编译这个程序为repid，此时这个程序的用户所有者ID是root，当我们以user1这个程序文件的时候，那么uid和euid的值就是user1用户的ID，因为进程保存的设置用户ID是复制有效用户ID的值，所以进程的保存的设置用户ID也是user1用户的ID。  </span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">    uid=<span class="number">1000</span>  </span><br><span class="line">    euid=<span class="number">1000</span>  </span><br><span class="line"> ```      </span><br><span class="line"></span><br><span class="line">如果root用户在编译完这个程序的时候，还设置了这个程序文件的设置用户位，那么user1用户执行这个程序文件打印的东西又会不一样了。 </span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">    uid=<span class="number">1000</span>  </span><br><span class="line">    euid=<span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>可以看到进程的有效用户ID被设置成了root用户的ID，也就是这个程序文件的所有者用户ID。对于此时的进程的保存的设置用户ID也是0。此时这个进程能够以root权限访问资源。<br>进程除了在初始化的时候，会设置这些ID之外，在执行过程中能够调用setuid和seteuid函数来设置实际用户ID和有效用户ID。</p>
<ol>
<li>若进程具有超级用户特权，则setuid函数讲实际用户ID，有效用户ID以及保存的设置用户ID设置为uid(这个uid是setuid函数的参数)。如果这个进程是调用setuid来设置有效用户ID，那么只会修改这个进程的有效用户ID，其他ID保持不变。</li>
<li>若进程没有超级用户特权，但是uid等于实际用户ID或保存的设置用户ID，则setuid只将有效用户ID设置为uid。如果这个进程是调用seteuid来设置有效用户ID，那么也是只能设置为其实际用户ID或保存的设置用户ID。</li>
</ol>
</div></article></div></main><footer><div class="paginator"><a href="/2018/07/07/signal/" class="prev">PREV</a><a href="/2018/07/07/processcontrol/" class="next">NEXT</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'longxq-github-io';
var disqus_identifier = '2018/07/07/pid/';
var disqus_title = 'Linux用户id';
var disqus_url = 'https://longxq.github.io/2018/07/07/pid/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//longxq-github-io.disqus.com/count.js" async></script><div class="copyright"><p>© 2015 - 2018 <a href="https://longxq.github.io">龙雄球</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>