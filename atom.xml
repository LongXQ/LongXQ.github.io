<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>oooo</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://longxq.github.io/"/>
  <updated>2018-07-07T14:24:29.065Z</updated>
  <id>https://longxq.github.io/</id>
  
  <author>
    <name>龙雄球</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>redisDB数据库实现</title>
    <link href="https://longxq.github.io/2018/07/07/redisdb/"/>
    <id>https://longxq.github.io/2018/07/07/redisdb/</id>
    <published>2018-07-07T14:22:59.004Z</published>
    <updated>2018-07-07T14:24:29.065Z</updated>
    
    <content type="html"><![CDATA[<p>Redis数据库就是以dict数据结构实现的。  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDb</span> &#123;</span>  </span><br><span class="line">    dict *dict;                 <span class="comment">/* The keyspace for this DB(数据库的键空间) */</span>  </span><br><span class="line">    dict *expires;              <span class="comment">/* Timeout of keys with a timeout set(记录一个有生存时间限制的键) */</span>  </span><br><span class="line">    dict *blocking_keys;        <span class="comment">/* Keys with clients waiting for data (BLPOP)(记录了client阻塞的键) */</span>  </span><br><span class="line">    dict *ready_keys;           <span class="comment">/* Blocked keys that received a PUSH */</span>  </span><br><span class="line">    dict *watched_keys;         <span class="comment">/* WATCHED keys for MULTI/EXEC CAS */</span>  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">evictionPoolEntry</span> *<span class="title">eviction_pool</span>;</span>    <span class="comment">/* Eviction pool of keys */</span>  </span><br><span class="line">    <span class="keyword">int</span> id;                     <span class="comment">/* Database ID(数据库ID，用来唯一标识这个数据库) */</span>  </span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> avg_ttl;          <span class="comment">/* Average TTL, just for stats */</span>  </span><br><span class="line">&#125; redisDb;</span><br></pre></td></tr></table></figure><p>一个redisDB就代表了一个Redis数据库，id记录了数据库的ID，数据存储在dict指针指向的hash table中。</p><a id="more"></a><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>当我们执行下面这条命令<br><code>LPUSH mylist longxiongqiu</code><br>Redis数据库是怎么样的呢?  </p><p><img src="/images/redisDB.png" alt="redis数据库">  </p><p>图中的REDIS_ENCODING_LINKEDLIST是list对象的一种对象编码，这种编码比较简单，和我们常见的linked list基本一样。<br>执行其他插入命令基本和这个一样。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Redis数据库就是以dict数据结构实现的。  &lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;redisDb&lt;/span&gt; &amp;#123;&lt;/span&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    dict *dict;                 &lt;span class=&quot;comment&quot;&gt;/* The keyspace for this DB(数据库的键空间) */&lt;/span&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    dict *expires;              &lt;span class=&quot;comment&quot;&gt;/* Timeout of keys with a timeout set(记录一个有生存时间限制的键) */&lt;/span&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    dict *blocking_keys;        &lt;span class=&quot;comment&quot;&gt;/* Keys with clients waiting for data (BLPOP)(记录了client阻塞的键) */&lt;/span&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    dict *ready_keys;           &lt;span class=&quot;comment&quot;&gt;/* Blocked keys that received a PUSH */&lt;/span&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    dict *watched_keys;         &lt;span class=&quot;comment&quot;&gt;/* WATCHED keys for MULTI/EXEC CAS */&lt;/span&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;evictionPoolEntry&lt;/span&gt; *&lt;span class=&quot;title&quot;&gt;eviction_pool&lt;/span&gt;;&lt;/span&gt;    &lt;span class=&quot;comment&quot;&gt;/* Eviction pool of keys */&lt;/span&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; id;                     &lt;span class=&quot;comment&quot;&gt;/* Database ID(数据库ID，用来唯一标识这个数据库) */&lt;/span&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; avg_ttl;          &lt;span class=&quot;comment&quot;&gt;/* Average TTL, just for stats */&lt;/span&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; redisDb;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;一个redisDB就代表了一个Redis数据库，id记录了数据库的ID，数据存储在dict指针指向的hash table中。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>RRedis Intset实现</title>
    <link href="https://longxq.github.io/2018/07/07/redis_intset/"/>
    <id>https://longxq.github.io/2018/07/07/redis_intset/</id>
    <published>2018-07-07T14:20:41.763Z</published>
    <updated>2018-07-07T14:22:45.695Z</updated>
    
    <content type="html"><![CDATA[<p>Redis Intset结构是用来实现REDIS_ENCODING_INTSET对象编码的。当一个Redis<br>set对象中所有的元素都是整数的时候适合用REDIS_ENCODING_INTSET对象编码来存储。<br>不同于数组，Intset能够存储不同字节长度的整数，并且是按照有序的方式存到intset结构中来的。</p><a id="more"></a><h3 id="Intset结构"><a href="#Intset结构" class="headerlink" title="Intset结构"></a>Intset结构</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span>&#123;</span>  </span><br><span class="line"><span class="keyword">uint32_t</span> encoding;  </span><br><span class="line"><span class="keyword">uint32_t</span> length;  </span><br><span class="line"><span class="keyword">int8_t</span> contents[];  </span><br><span class="line">&#125;intset;</span><br></pre></td></tr></table></figure><ol><li>length字段表示目前intset结构中有多少个元素。  </li><li>contents为占位符，代表元素的起始地址。  </li><li>Intset结构中的encoding字段可以有以下的取值:   </li></ol><pre><code class="c"><span class="meta">#<span class="meta-keyword">define</span> INTSET_ENC_INT16 (sizeof(int16_t))  </span><span class="meta">#<span class="meta-keyword">define</span> INTSET_ENC_INT32 (sizeof(int32_t))  </span><span class="meta">#<span class="meta-keyword">define</span> INTSET_ENC_INT64 (sizeof(int64_t)) </span></code></pre><ol><li>INTSET_ENC_INT16表示当前intset结构中的元素按照16位的整数来存储的</li><li>INTSET_ENC_INT32表示当前intset结构中的元素按照32位的整数来存储的</li><li>INTSET_ENC_INT64表示当前intset结构中的元素按照64位的整数来存储的</li></ol><p>特别注意的是，encoding字段取值只能前进不能倒退，意思就是如果如果当前encoding字段的值是INTSET_ENC_INT32，那么就不能在给encoding赋值为INTSET_ENC_INT16了，只能保持不变或者赋值为INTSET_ENC_INT64。</p><h3 id="新建一个Intset结构"><a href="#新建一个Intset结构" class="headerlink" title="新建一个Intset结构"></a>新建一个Intset结构</h3><p>新建一个Intset结构时，默认的encoding字段设置为INTSET_ENC_INT16，表示当前intset结构中的整数按照16位整数来进行存取，初始的时候长度为0所以length字段设置为0 </p><p><img src="/images/emptyintset.png" alt="empty intset"></p><h3 id="Intset元素插入"><a href="#Intset元素插入" class="headerlink" title="Intset元素插入"></a>Intset元素插入</h3><p>当插入一个整数的时候，首先intset会检查该整数的最小编码方式，看最小能够用多少个字节来存储这个整数，如果能够用2个字节来存储这个整数，则这个整数的最小编码就是INTSET_ENC_INT16，如果要用4个字节来存储，最小编码就是INTSET_ENC_INT32，如果要用8个字节来存储，最小编码就是INTSET_ENC_INT64。</p><h3 id="插入最小编码为INTSET-ENC-INT16的整数"><a href="#插入最小编码为INTSET-ENC-INT16的整数" class="headerlink" title="插入最小编码为INTSET_ENC_INT16的整数"></a>插入最小编码为INTSET_ENC_INT16的整数</h3><p>刚开始时，encoding字段也是INTSET_ENC_INT16，所以intset会按照encoding的方式来存储这个整数。<br>首先在intset中查找当前整数是否已经在intset中了，如果已经存在则不插入，如果不存在则分配两个字节的空间给新元素，找到插入点，然后插入进去。由于刚开始时，intset为空，所以直接插入到第一个位置。</p><p><img src="/images/INTSET_ENC_INT16.png" alt="INTSET_ENC_INT16">  </p><p>我们在插入一个INTSET_ENC_INT16的整数。首先调整intset的大小，新分配两个字节的空间，在找到待插入点，假设当前元素比intset中存在的元素小，那么应该把待插入的元素插入到起始位置，所以首先要进行数据移位，然后再插入。 </p><p><img src="/images/INTSET_ENC_INT16_1.png" alt="INTSET_ENC_INT16"></p><h3 id="插入一个最小编码为INTSET-ENC-INT32的整数"><a href="#插入一个最小编码为INTSET-ENC-INT32的整数" class="headerlink" title="插入一个最小编码为INTSET_ENC_INT32的整数"></a>插入一个最小编码为INTSET_ENC_INT32的整数</h3><p>因为插入的元素要用4个字节存储，如果还是按照原先的encoding方式进行内存分配和移动位置的话，显然覆盖掉原先的元素。<br>首先intset把encoding赋值为新值INTSET_ENC_32。然后把以前旧的元素的最小编码进行提升，也就是通通改成INTSET_ENC_INT32的编码方式，用4个字节进行存储。所以接下来就是调整数据空间的大小，因为当前intset中已经有2个元素了，占用了4个字节，最小编码提升后，由于每一个元素要占用4个字节，所以旧元素总共要新增4个字节，在加上新插入的元素总共要增加8个字节的空间。</p><p><img src="/images/INTSET_ENC_INT32.png" alt="INTSET_ENC_INT32"> </p><p>由于新插入的元素要么比当前intset中的元素都要大，要么都要小(因为当前intset中的元素以前都是INTSET_ENC_16编码的，也就是2个字节的整数，所以当前插入的元素是4个字节整数的，要么比当前intset中的元素都大，要么都要小(负数))，所以要么是插入到头部，要么是插入到尾部，假设插入的元素比当前intset中的元素都要小，所以插入到头部。</p><p><img src="/images/INTSET_ENC_INT32_1.png" alt="INTSET_ENC_INT32">  </p><p>如果后续插入编码方式为INTSET_ENC_INT16的整数，那么由于当前encoding为INTSET_ENC_INT32，所以要按照encoidng的方式插入整数。如果后续插入的是INTSET_ENC_INT64的整数，则按照前面的方法一样。<br>至于从intset中删除元素，则很简单了，按照当前encoding的方式删除元素即可。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Redis Intset结构是用来实现REDIS_ENCODING_INTSET对象编码的。当一个Redis&lt;br&gt;set对象中所有的元素都是整数的时候适合用REDIS_ENCODING_INTSET对象编码来存储。&lt;br&gt;不同于数组，Intset能够存储不同字节长度的整数，并且是按照有序的方式存到intset结构中来的。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Redis dict实现</title>
    <link href="https://longxq.github.io/2018/07/07/redis_dict/"/>
    <id>https://longxq.github.io/2018/07/07/redis_dict/</id>
    <published>2018-07-07T14:16:25.536Z</published>
    <updated>2018-07-07T14:20:22.919Z</updated>
    
    <content type="html"><![CDATA[<p>dict数据结构在Redis中是一个重要的部分，REDIS_ENCODING_HT对象编码就是用dict实现的，而且Redis的数据库也是利用dict来实现的。</p><a id="more"></a><h3 id="dict实现的相关数据结构"><a href="#dict实现的相关数据结构" class="headerlink" title="dict实现的相关数据结构:"></a>dict实现的相关数据结构:</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span>&#123;</span>  </span><br><span class="line">dictType *type;  </span><br><span class="line"><span class="keyword">void</span> *privdata;  </span><br><span class="line">dictht ht[<span class="number">2</span>];  </span><br><span class="line"><span class="keyword">long</span> rehashidx;  </span><br><span class="line"><span class="keyword">int</span> iterators;  </span><br><span class="line">&#125;dict;</span><br></pre></td></tr></table></figure><p>一个dict结构里面包含了两个hash table(ht[2])。</p><pre><code class="c"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span>{</span>      dictEntry **table;      <span class="keyword">unsigned</span> <span class="keyword">long</span> size;      <span class="keyword">unsigned</span> <span class="keyword">long</span> sizemask;      <span class="keyword">unsigned</span> <span class="keyword">long</span> used;  }</code></pre><p>size字段表示table数组的大小，table是一个dictEntry*数组，它的大小始终为2的倍数。used表示当前hash<br>table中dictEntry的个数。</p><pre><code class="c"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span>{</span>      <span class="keyword">void</span> *key;      <span class="keyword">union</span>{          <span class="keyword">void</span> *val;          uint64_6 u64;          <span class="keyword">int64_t</span> s64;          <span class="keyword">double</span> d;      }v;      <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span>  }dictEntry;  </code></pre><p>dictEntry就是hash table中的条目，每一个条目代表一个key-value对。<br>下面是一个空的dict:</p><p><img src="/images/dict.png" alt="空的dict"></p><p>往空的dict中插入一个key-value对.当是第一次往dict中插入元素的时候，由于dict中ht[0]和ht[1]中table数组都是空的，所以系统一开始在第一次插入元素的时候会初始化ht[0]-&gt;table，初始该table数组长度为4，并初始化数组中每一个dictEntry指针为NULL。</p><p><img src="/images/dict_0.png" alt="dict"> </p><p>接着在初始化一个dictEntry，它的key字段就是key-value对中的key，它的v字段就是value。然后使用hash算法算出key-value对中key对应的hash值，然后除以ht[0]-&gt;sizemask，余数就是插入的位置。  </p><pre><code class="c"><span class="keyword">int</span> i=hash(key);  <span class="keyword">int</span> index=key%ht[<span class="number">0</span>]-&gt;sizemask; </code></pre><p><img src="/images/dict_1.png" alt="dict"></p><p>到此为止一个key-value对就插入到dict中了。</p><h3 id="rehash过程"><a href="#rehash过程" class="headerlink" title="rehash过程"></a>rehash过程</h3><p>当ht[0]中的元素太多的时候，dict就会进行扩大hash table。但是这里的扩大不是指扩大原有的ht[0]的大小，而是新初始化一个更大的hash table，并让ht[1]-&gt;table指向它。新的分配的hash table的大小是在ht[0]-&gt;used的两倍的基础上调整为2的倍数。  </p><p><img src="/images/dict_2.png" alt="dict">  </p><p>我们可以看到ht[0]中当前有30个元素，dict新建了一个size等于60的hash table并让ht[1]-&gt;table指向它。<br>为什么要这么做？这么做的目的就是进行rehash。那为什么又要rehash呢？<br>原因就是当ht[0]-&gt;table中的元素越来越多的时候，会导致定位当某一个元素越来越费时间，导致效率变低。所以必须要重新rehash到一个更大的hash<br>table中去，使得元素均匀分布在hash table中。所以这就是为什么dict需要两个dictht结构的原因。ht[1]就是用来rehash的。<br>当ht[1]-&gt;table准备就绪后，就可以开始进行rehash了，rehash过程就和插入一个元素到ht[0]-&gt;table中去差不多，就是把ht[0]-&gt;table中的每一个元素的key值重新hash一次，然后再插入到ht[1]-&gt;table中来。</p><p><img src="/images/dict_3.png" alt="dict">  </p><p>当ht[0]-&gt;table中的所有元素都被rehash到ht[1]-&gt;table中去，则释放掉ht[0]-&gt;table数组，然后让ht[0]-&gt;table指向ht[1]-&gt;table，调整ht[0]其他字段的值并对ht[1]进行重置操作。</p><p><img src="/images/dict_4.png" alt="dict"></p><h3 id="逐次rehash操作"><a href="#逐次rehash操作" class="headerlink" title="逐次rehash操作"></a>逐次rehash操作</h3><p>dict并不是一次性把ht[0]-&gt;table中的所有元素rehash到新的hash<br>table中去的，因为当旧table中元素太多的时候，这样很费时间，所以dict采取的是逐次rehash。一次rehash过程有可能rehash掉ht[0]-&gt;table[0]中的所有元素，有可能还会rehash掉ht[0]-&gt;table[1]中的所有元素，但是不会rehash掉所有的，也不会rehash掉ht[0]-&gt;table[1]中的一部分元素就退出了，要么rehashht[0]-&gt;table[1]中的所有的元素要么就不会rehash。<br>dict结构的rehashidx字段记录了目前rehash过程到哪一个ht[0]-&gt;table数组中的元素了。当全部rehash操作完成，rehashidx字段重置为-1。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;dict数据结构在Redis中是一个重要的部分，REDIS_ENCODING_HT对象编码就是用dict实现的，而且Redis的数据库也是利用dict来实现的。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Redis ziplist实现</title>
    <link href="https://longxq.github.io/2018/07/07/ziplist/"/>
    <id>https://longxq.github.io/2018/07/07/ziplist/</id>
    <published>2018-07-07T14:08:49.456Z</published>
    <updated>2018-07-07T14:14:45.983Z</updated>
    
    <content type="html"><![CDATA[<p>ziplist结构是Redis内部用来实现REDIS_ENCODING_ZIPLIST对象编码的。</p><a id="more"></a><h3 id="ziplist结构分析"><a href="#ziplist结构分析" class="headerlink" title="ziplist结构分析"></a>ziplist结构分析</h3><p>首先我们从总体上来看下ziplist结构的总体布局:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">zlbytes</span>&gt;</span><span class="tag">&lt;<span class="name">zltail</span>&gt;</span><span class="tag">&lt;<span class="name">zllen</span>&gt;</span><span class="tag">&lt;<span class="name">entry</span>&gt;</span><span class="tag">&lt;<span class="name">entry</span>&gt;</span>...<span class="tag">&lt;<span class="name">entry</span>&gt;</span><span class="tag">&lt;<span class="name">zlend</span>&gt;</span></span><br></pre></td></tr></table></figure><p>接着看看ziplist中每一个部分的作用.</p><h3 id="ziplist的头部"><a href="#ziplist的头部" class="headerlink" title="ziplist的头部"></a>ziplist的头部</h3><pre><code class="html"><span class="tag">&lt;<span class="name">zlbytes</span>&gt;</span><span class="tag">&lt;<span class="name">zltail</span>&gt;</span><span class="tag">&lt;<span class="name">zllen</span>&gt;</span>  </code></pre><p>一起组成了ziplist的头部部分。这三部分描述了一个ziplist结构的总体信息:</p><ol><li><code>&lt;zlbytes&gt;</code>是一个unsigned integer，表示ziplist所占用的字节数大小。</li><li><code>&lt;zltail&gt;</code>表示到最后一个entry的字节偏移量。有了这个字段我们就能很快定位到最后一个entry</li><li><code>&lt;zllen&gt;</code>代表了当前ziplist中有多少个entry。</li></ol><h3 id="lt-entry-gt-部分"><a href="#lt-entry-gt-部分" class="headerlink" title="&lt;entry&gt;部分"></a><code>&lt;entry&gt;</code>部分</h3><p>一个<code>&lt;entry&gt;</code>就代表了ziplist中的一个元素。如果一个ziplist中没有一个元素，说明此时ziplist是一个空的，不存在任何数据。大于等于0个<code>&lt;entry&gt;</code>构成了ziplist的主体部分。下面来看看<code>&lt;entry&gt;</code>结构是个什么样子。<br>特别注意的是<code>&lt;entry&gt;</code>的大小不是固定不变的，不同的<code>&lt;entry&gt;</code>它的大小有可能是不一样的。下面是<code>&lt;entry&gt;</code>的结构:  </p><p><img src="/images/ZiplistEntry.png" alt="entry结构"> </p><p>首先<code>&lt;entry&gt;</code>的header中的第一部分表示前一个的大小。这一部分的长度不是固定的，根据前一个<code>&lt;entry&gt;</code>的大小的不同而不同:</p><ol><li>如果前一个<code>&lt;entry&gt;</code>的大小小于254字节，那么这一部分就占用一个字节的大小来表示前一个<code>&lt;entry&gt;</code>的大小</li><li>如果前一个<code>&lt;entry&gt;</code>的大小大于或者等于254个字节，那么这一部分就占用5个字节来表示前一个<code>&lt;entry&gt;</code>的大小。其中第一个字节被设置成254，用来表明接下来要用4个字节来表达前一个<code>&lt;entry&gt;</code>的大小。</li></ol><p>在来看看<code>&lt;entry&gt;</code>的header中第二部分。这一部分是<code>&lt;entry&gt;</code>的类型和大小编码。用来描述这个<code>&lt;entry&gt;</code>数据部分存储的是一串字符串还是一个整数，并描述了<code>&lt;entry&gt;</code>数据部分用来存储这些数据所占用的字节数大小。</p><h3 id="当数据部分是一串字符串的时候"><a href="#当数据部分是一串字符串的时候" class="headerlink" title="当数据部分是一串字符串的时候"></a>当数据部分是一串字符串的时候</h3><ol><li>|00pppppp| - 当数据部分是一串字符串且大小小于或等于63个字节的时候，该部分占用1一个字节。前2个比特位设置成00，后面的6个比特位用来描述数据部分的大小</li><li>|01pppppp|qqqqqqqq| - 当数据部分是一串字符串且大小小于或者等于16383字节(14个比特位表示)的时候，该部分占用2个字节的大小，前2个比特位被设置成01，后面的14个比特位描述数据部分的大小。</li><li>|10 <strong>__</strong> |qqqqqqqq|rrrrrrrr|ssssssss|tttttttt| - 当数据部分是一串字符串的时候并且大小大于或者等于16384字节的时候，该部分占用5个字节大小，前2个比特位被设置成10，后4个字节用来描述数据部分的大小。</li></ol><h5 id="当数据部分是整数的时候"><a href="#当数据部分是整数的时候" class="headerlink" title="当数据部分是整数的时候"></a>当数据部分是整数的时候</h5><p>当数据部分是一个整数的时候，该部分只占用了1个字节的大小。其中前2个比特位被设置成11，表示<code>&lt;entry&gt;</code>的数据部分是一个整数。后6个比特位用来表示该整数占用的字节数。</p><ol start="4"><li>|11000000| - 表明数据部分占用了2个字节，存储的是一个int16_t类型的整数</li><li>|11010000| - 表明数据部分占用了4个字节，存储的是一个int32_t类型的整数</li><li>|11100000| - 表明数据部分占用了8个字节，存储的是一个int64_t类型的整数</li><li>|11110000| - 表明数据部分占用了3个字节，存储的是一个24比特位的整数</li><li>|11111110| - 表明数据部分占用了1个字节，存储的是8比特位的整数</li><li>|1111xxxx| - 此时该<code>&lt;entry&gt;</code>无数据部分。当存储的整数是0~12的时候，直接用该部分的后4个比特位来表示。因为后4个比特位不能为0000和1110和1111，所以xxxx能够表示的范围为0001~1101，也就是能够表示的整数位1~13，但是我们要表示的是整数范围是0~12，所以为了取得正确的值，记得要进行减一操作。</li></ol><h3 id="lt-zlend-gt"><a href="#lt-zlend-gt" class="headerlink" title="&lt;zlend&gt;"></a><code>&lt;zlend&gt;</code></h3><h2 id="lt-zlend-gt-是ziplist的尾部，它占用一个字节，被固定设置成255，用来表示该位置是ziplist的结束部分了。"><a href="#lt-zlend-gt-是ziplist的尾部，它占用一个字节，被固定设置成255，用来表示该位置是ziplist的结束部分了。" class="headerlink" title="&lt;zlend&gt;是ziplist的尾部，它占用一个字节，被固定设置成255，用来表示该位置是ziplist的结束部分了。"></a><code>&lt;zlend&gt;</code>是ziplist的尾部，它占用一个字节，被固定设置成255，用来表示该位置是ziplist的结束部分了。</h2><h3 id="Redis-list类型"><a href="#Redis-list类型" class="headerlink" title="Redis list类型"></a>Redis list类型</h3><p>接下来我们看看Redis list类型的数据怎么用ziplist来实现REDIS_ENCODING_ZIPLIST对象编码的。<br>假如一个list对象由三个元素组成:valxxx…xxx56,valxxx…xxx256,10,65530。第一个元素是大小为56个字节的字符串，第二个元素是大小为256的字符串，第三个和第四个元素都是整数。我们看看怎么用REDIS_ENCODING_ZIPLIST对象编码来存储的。  </p><p><img src="/images/REDIS_ENCODING_ZIPLIST.png" alt="REDIS_ENCODING_ZIPLIST">  </p><p>再来看看一个完整的使用了REDIS_ENCODING_ZIPLIST对象编码的Redis list对象的结构:  </p><p><img src="/images/redis_list_1.png" alt="REDIS_LIST"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ziplist结构是Redis内部用来实现REDIS_ENCODING_ZIPLIST对象编码的。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Redis dynamic strings</title>
    <link href="https://longxq.github.io/2018/07/07/redis2/"/>
    <id>https://longxq.github.io/2018/07/07/redis2/</id>
    <published>2018-07-07T12:06:59.629Z</published>
    <updated>2018-07-07T14:07:53.772Z</updated>
    
    <content type="html"><![CDATA[<p>在讲述其他Redis类型和对象编码前，我们先来看看Redis中最简单的类型String。<br>String是Redis诸多类型中最基本的类型，它是lists，hashes，sets等类型的基本组成部分。<br>我们知道Redis是以key-value方式存储的。所有的Redis keys都是string类型，同时string也是最简单的value类型。<br>接下来我们看看string类型在Redis中是怎么实现的。</p><a id="more"></a><h2 id="Redis-string的实现"><a href="#Redis-string的实现" class="headerlink" title="Redis string的实现"></a>Redis string的实现</h2><p>一个C结构sdshdr代表一个Redis string: </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span>&#123;</span>  </span><br><span class="line">    <span class="keyword">long</span> len;  </span><br><span class="line">    <span class="keyword">long</span> <span class="built_in">free</span>;  </span><br><span class="line">    <span class="keyword">char</span> buf[];  </span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><p>所以我们看到string类型的实现在Redis内部就是一个sdshdr类型。buf字符数组存储真实的字符串数据。len字段存储着buf的长度。free字段存储的buf数组中目前还有多少可用字节。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> *sds;</span><br></pre></td></tr></table></figure><p>在Redis内部还定义了一个sds类型，其实就是一个字符串指针。一个sds对象就是一个指针，这个指针指向一个sdshdr对象的buf部分，也就是Redis<br>string对象的实际数据部分。<br>假设我们新建了一个内容为”hello,world”字符串的redis string，我们来看看他们redis内部是怎么表示的:<br><img src="/images/String.png" alt="Redis string"><br>可以看到stringObj就是一个string对象，p是一个sds对象，指向了stringObj的buf部分。在实际中，我们不直接使用一个string对象，而是间接的使用sds对象来操作string对象，毕竟我们只需要string对象中的真实数据。</p><h2 id="Redis-string类型的对象编码"><a href="#Redis-string类型的对象编码" class="headerlink" title="Redis string类型的对象编码"></a>Redis string类型的对象编码</h2><p>String类型的对象有三种编码方式:  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ENCODING_RAW 0  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ENCODING_INT 1  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ENCODING_EMBSTR 8</span></span><br></pre></td></tr></table></figure><p>首先我们看第一种编码方式。</p><h3 id="REDIS-ENCODING-RAW"><a href="#REDIS-ENCODING-RAW" class="headerlink" title="REDIS_ENCODING_RAW"></a>REDIS_ENCODING_RAW</h3><p>REDIS_ENCODING_RAW编码方式很简单，其实就是把一个sds对象赋值给robj对象的ptr指针。<br>我们来看看Redis内部是怎么以REDIS_ENCODING_RAW编码方式来存储string对象的:</p><ol><li>首先新建一个robj对象，然后把type设置为REDIS_STRING，把encoidng设置为REDIS_ENCODING_RAW:</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">robj *stringObj=<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(robj));  </span><br><span class="line">    stringObj-&gt;type=REDIS_STRING;  </span><br><span class="line">    stringObj-&gt;encoidng=REDIS_ENCODING_RAW;</span><br></pre></td></tr></table></figure><ol start="2"><li><p>然后新建一个sdshdr对象sh和sds对象p，把实际的数据存储到sh中，并把buf赋值给p。</p></li><li><p>把上面新建的sds对象赋值给stringObj的ptr指针。</p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stringObj-&gt;ptr=p;</span><br></pre></td></tr></table></figure><p><img src="/images/REDIS_ENCODING_RAW.png" alt="REDIS_ENCODING_RAW"></p><h3 id="REDIS-ENCODING-INT"><a href="#REDIS-ENCODING-INT" class="headerlink" title="REDIS_ENCODING_INT"></a>REDIS_ENCODING_INT</h3><p>当一串字符串可以转换成整数时候，就用REDIS_ENCODING_INT编码方式来存储这串字符串，这种编码方式是先把字符串转换成整数，然后直接赋值给robj对象的ptr指针，这样就节省了sdshdr结构所占用的内存，而且数据部分也节省了很多内存，以字符串”123456789123456789”为例:</p><ol><li>首先新建了一个robj对象o。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">o-&gt;type=REDIS_STRING;  </span><br><span class="line">o-&gt;encoidng=REDIS_ENCOIDNG_INT;</span><br></pre></td></tr></table></figure><ol start="2"><li>然后把字符串转换成整数p，以”123456789123456789”为例就是:</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> p=<span class="number">123456789123456789</span>;</span><br></pre></td></tr></table></figure><ol start="3"><li>直接把p赋值给o-&gt;ptr，而不是新建sdshdr对象:</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">o-&gt;ptr=(<span class="keyword">void</span>*)p;</span><br></pre></td></tr></table></figure><p><img src="/images/REDIS_ENCODING_INT.png" alt="REDIS_ENCODING_INT">  </p><p>我们可以看到这样可以节省很多内存。</p><h3 id="REDIS-ENCODING-EMBSTR"><a href="#REDIS-ENCODING-EMBSTR" class="headerlink" title="REDIS_ENCODING_EMBSTR"></a>REDIS_ENCODING_EMBSTR</h3><p>顾名思义这种编码方式就是把sdshdr对象内嵌到robj对象中，使他们形成一个整体。  </p><p><img src="/images/REDIS_ENCODING_EMBSTR.png" alt="REDIS_ENCODING_EMBSTR"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在讲述其他Redis类型和对象编码前，我们先来看看Redis中最简单的类型String。&lt;br&gt;String是Redis诸多类型中最基本的类型，它是lists，hashes，sets等类型的基本组成部分。&lt;br&gt;我们知道Redis是以key-value方式存储的。所有的Redis keys都是string类型，同时string也是最简单的value类型。&lt;br&gt;接下来我们看看string类型在Redis中是怎么实现的。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>redis对象系统</title>
    <link href="https://longxq.github.io/2018/07/07/redis1/"/>
    <id>https://longxq.github.io/2018/07/07/redis1/</id>
    <published>2018-07-07T10:27:59.830Z</published>
    <updated>2018-07-07T13:57:42.539Z</updated>
    
    <content type="html"><![CDATA[<p>redis是什么？移步<a href="www.redis.io">redis官网</a>。<br>redis支持的数据结构类型有很多，从简单的strings，到hashes，lists，sets，sorted<br>sets等。那么redis内部是怎么组织数据的呢？本文的目的就是梳理redis内部数据结构的实现方式，看看数据在redis内部是怎么存储的。</p><a id="more"></a><h3 id="redis对象"><a href="#redis对象" class="headerlink" title="redis对象"></a>redis对象</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span>&#123;</span>  </span><br><span class="line"><span class="keyword">unsigned</span> type:<span class="number">4</span>;  </span><br><span class="line"><span class="keyword">unsigned</span> encoding:<span class="number">4</span>;  </span><br><span class="line"><span class="keyword">unsigned</span> lru:REDIS_LRU_BITS;    <span class="comment">/* 和LRU算法相关的字段(先可以不关注这个字段) */</span>  </span><br><span class="line"><span class="keyword">int</span> refcount;    <span class="comment">/* 引用次数，因为一个对象可能会被共享 */</span>  </span><br><span class="line"><span class="keyword">void</span> *ptr;  </span><br><span class="line">&#125;robj;</span><br></pre></td></tr></table></figure><p>一个redis对象就是一个robj对象。  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_STRING 0  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_LIST 1  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_SET 2  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ZSET 3  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_HASH 4</span></span><br></pre></td></tr></table></figure><p>假如我们在一个robj对象内存储的是数据结构类型为string的对象，那么type就是REDIS_STRING，表示这个robj对象代表一个string类型的对象，而实际的这个string类型的对象由robj结构体中的ptr指针指向。假如是一个list对象，那么type字段的就是REDIS_LIST，表示这个robj对象代表一个list类型的对象，而实际的这个list类型的对象由ptr指针指向。</p><h3 id="对象编码"><a href="#对象编码" class="headerlink" title="对象编码"></a>对象编码</h3><p>现在我们要新建一个由val1，val2和val3组成的list。那么redis是如何实现的呢？首先当然是创建一个robj对象，并且把type赋值为REDIS_LIST，引用计数设置为1。  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">robj *listObj=<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(robj));  </span><br><span class="line">listObj-&gt;type=REDIS_LIST;  </span><br><span class="line">listObj-&gt;ref=<span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>那么redis内部是怎么表示这个由val1,val2,val3组成的list的呢？常规的方法可能是下面这样组织的:<br><img src="/images/list1.png" alt="list1"><br>我们也可以以数组的形式存储这个list:<br><img src="/images/list2.png" alt="list2"><br>这两种构造list的方式就是两种针对list类型对象的编码。对象的编码其实就是数据的组织方式，比如这里的list对象的数据组织既可以用链表的形式组织，也可以用数组的形式组织。为了知道当前对象是怎么编码的，我们把编码的代号赋值给robj结构的encoding字段。我们把第一种编码叫做NORMAL_LIST，第二种叫做ARRAY_LIST。当然redis内部是没有这两种编码的，在这里只是为了解释什么是对象编码。下面就是redis目前支持的编码种类，这些编码方式都是结合了性能和存储效率这两方面的。  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ENCODING_RAW 0    <span class="comment">/* Raw representation */</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ENCODING_INT 1    <span class="comment">/* 编码为整数 */</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ENCODING_HT 2     <span class="comment">/* 编码为hash table */</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ENCODING_ZIPMAP 3    <span class="comment">/* 编码为zipmap */</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ENCODING_LINKEDLIST 4    <span class="comment">/* 编码为普通的linked list */</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ENCODING_ZIPLIST 5    <span class="comment">/* 编码为ziplist */</span>      </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ENCODING_INTSET 6    <span class="comment">/* 编码为intset */</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ENCODING_SKIPLIST 7    <span class="comment">/* 编码为skiplist */</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ENCODING_EMBSTR 8    <span class="comment">/*编码为嵌入的sds string */</span></span></span><br></pre></td></tr></table></figure><p>接下来的一系列文章都会一一讲解这些编码方式，看看redis内部是怎么实现对象的存储的</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;redis是什么？移步&lt;a href=&quot;www.redis.io&quot;&gt;redis官网&lt;/a&gt;。&lt;br&gt;redis支持的数据结构类型有很多，从简单的strings，到hashes，lists，sets，sorted&lt;br&gt;sets等。那么redis内部是怎么组织数据的呢？本文的目的就是梳理redis内部数据结构的实现方式，看看数据在redis内部是怎么存储的。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
