<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Redis dict实现 · oooo</title><meta name="description" content="Redis dict实现 - 龙雄球"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://longxq.github.io/atom.xml" title="oooo"></head><body><div class="wrap"><header><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/LongXQ" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xm" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">Redis dict实现</h1><div class="post-info">Jul 7, 2018</div><div class="post-content"><p>dict数据结构在Redis中是一个重要的部分，REDIS_ENCODING_HT对象编码就是用dict实现的，而且Redis的数据库也是利用dict来实现的。</p>
<a id="more"></a>
<h3 id="dict实现的相关数据结构"><a href="#dict实现的相关数据结构" class="headerlink" title="dict实现的相关数据结构:"></a>dict实现的相关数据结构:</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span>&#123;</span>  </span><br><span class="line">	dictType *type;  </span><br><span class="line">	<span class="keyword">void</span> *privdata;  </span><br><span class="line">	dictht ht[<span class="number">2</span>];  </span><br><span class="line">	<span class="keyword">long</span> rehashidx;  </span><br><span class="line">	<span class="keyword">int</span> iterators;  </span><br><span class="line">&#125;dict;</span><br></pre></td></tr></table></figure>
<p>一个dict结构里面包含了两个hash table(ht[2])。</p>
<pre><code class="c"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span>{</span>  
    dictEntry **table;  
    <span class="keyword">unsigned</span> <span class="keyword">long</span> size;  
    <span class="keyword">unsigned</span> <span class="keyword">long</span> sizemask;  
    <span class="keyword">unsigned</span> <span class="keyword">long</span> used;  
}
</code></pre>
<p>size字段表示table数组的大小，table是一个dictEntry*数组，它的大小始终为2的倍数。used表示当前hash<br>table中dictEntry的个数。</p>
<pre><code class="c"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span>{</span>  
    <span class="keyword">void</span> *key;  
    <span class="keyword">union</span>{  
        <span class="keyword">void</span> *val;  
        uint64_6 u64;  
        <span class="keyword">int64_t</span> s64;  
        <span class="keyword">double</span> d;  
    }v;  
    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span>  
}dictEntry;  
</code></pre>
<p>dictEntry就是hash table中的条目，每一个条目代表一个key-value对。<br>下面是一个空的dict:</p>
<p><img src="/images/dict.png" alt="空的dict"></p>
<p>往空的dict中插入一个key-value对.当是第一次往dict中插入元素的时候，由于dict中ht[0]和ht[1]中table数组都是空的，所以系统一开始在第一次插入元素的时候会初始化ht[0]-&gt;table，初始该table数组长度为4，并初始化数组中每一个dictEntry指针为NULL。</p>
<p><img src="/images/dict_0.png" alt="dict"> </p>
<p>接着在初始化一个dictEntry，它的key字段就是key-value对中的key，它的v字段就是value。然后使用hash算法算出key-value对中key对应的hash值，然后除以ht[0]-&gt;sizemask，余数就是插入的位置。  </p>
<pre><code class="c"><span class="keyword">int</span> i=hash(key);  
<span class="keyword">int</span> index=key%ht[<span class="number">0</span>]-&gt;sizemask; 
</code></pre>
<p><img src="/images/dict_1.png" alt="dict"></p>
<p>到此为止一个key-value对就插入到dict中了。</p>
<h3 id="rehash过程"><a href="#rehash过程" class="headerlink" title="rehash过程"></a>rehash过程</h3><p>当ht[0]中的元素太多的时候，dict就会进行扩大hash table。但是这里的扩大不是指扩大原有的ht[0]的大小，而是新初始化一个更大的hash table，并让ht[1]-&gt;table指向它。新的分配的hash table的大小是在ht[0]-&gt;used的两倍的基础上调整为2的倍数。  </p>
<p><img src="/images/dict_2.png" alt="dict">  </p>
<p>我们可以看到ht[0]中当前有30个元素，dict新建了一个size等于60的hash table并让ht[1]-&gt;table指向它。<br>为什么要这么做？这么做的目的就是进行rehash。那为什么又要rehash呢？<br>原因就是当ht[0]-&gt;table中的元素越来越多的时候，会导致定位当某一个元素越来越费时间，导致效率变低。所以必须要重新rehash到一个更大的hash<br>table中去，使得元素均匀分布在hash table中。所以这就是为什么dict需要两个dictht结构的原因。ht[1]就是用来rehash的。<br>当ht[1]-&gt;table准备就绪后，就可以开始进行rehash了，rehash过程就和插入一个元素到ht[0]-&gt;table中去差不多，就是把ht[0]-&gt;table中的每一个元素的key值重新hash一次，然后再插入到ht[1]-&gt;table中来。</p>
<p><img src="/images/dict_3.png" alt="dict">  </p>
<p>当ht[0]-&gt;table中的所有元素都被rehash到ht[1]-&gt;table中去，则释放掉ht[0]-&gt;table数组，然后让ht[0]-&gt;table指向ht[1]-&gt;table，调整ht[0]其他字段的值并对ht[1]进行重置操作。</p>
<p><img src="/images/dict_4.png" alt="dict"></p>
<h3 id="逐次rehash操作"><a href="#逐次rehash操作" class="headerlink" title="逐次rehash操作"></a>逐次rehash操作</h3><p>dict并不是一次性把ht[0]-&gt;table中的所有元素rehash到新的hash<br>table中去的，因为当旧table中元素太多的时候，这样很费时间，所以dict采取的是逐次rehash。一次rehash过程有可能rehash掉ht[0]-&gt;table[0]中的所有元素，有可能还会rehash掉ht[0]-&gt;table[1]中的所有元素，但是不会rehash掉所有的，也不会rehash掉ht[0]-&gt;table[1]中的一部分元素就退出了，要么rehashht[0]-&gt;table[1]中的所有的元素要么就不会rehash。<br>dict结构的rehashidx字段记录了目前rehash过程到哪一个ht[0]-&gt;table数组中的元素了。当全部rehash操作完成，rehashidx字段重置为-1。</p>
</div></article></div></main><footer><div class="paginator"><a href="/2018/07/07/redis_intset/" class="prev">PREV</a><a href="/2018/07/07/ziplist/" class="next">NEXT</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'longxq-github-io';
var disqus_identifier = '2018/07/07/redis_dict/';
var disqus_title = 'Redis dict实现';
var disqus_url = 'https://longxq.github.io/2018/07/07/redis_dict/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//longxq-github-io.disqus.com/count.js" async></script><div class="copyright"><p>© 2015 - 2018 <a href="https://longxq.github.io">龙雄球</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>