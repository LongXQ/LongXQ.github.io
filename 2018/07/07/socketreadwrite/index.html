<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> TCP关闭后的读写总结 · oooo</title><meta name="description" content="TCP关闭后的读写总结 - 龙雄球"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://longxq.github.io/atom.xml" title="oooo"></head><body><div class="wrap"><header><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/LongXQ" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xm" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">TCP关闭后的读写总结</h1><div class="post-info">Jul 7, 2018</div><div class="post-content"><p>一个TCP连接，相当于建立两条独立的通信管道，两端可以进行全双工通信，能够进行读和写。</p>
<p><img src="/images/TCP连接.jpg" alt="一个TCP连接"></p>
<a id="more"></a>
<h3 id="调用close系统调用关闭"><a href="#调用close系统调用关闭" class="headerlink" title="调用close系统调用关闭"></a>调用close系统调用关闭</h3><p>主机A调用close系统调用，相当于发送FIN报文段给B，通知它自己要关闭A到B的写管道了。B收到FIN报文段后，发送ACK确认报文段给A，说明它知道了。<br>然后B在自己执行被动关闭，关闭自己这端的管道。这样一条TCP连接就被完整的关闭了，在两端也就不存在了。那当对通过close系统关闭的TCP进行读和写会发生什么了。 </p>
<p><img src="/images/close_1.png" alt="对一个已经关闭的socket进行写操作"> </p>
<p>server端对一个已经关闭的socket调用了两次send写操作：(1)处的send将会把数据发送给client，由于连接已经被关闭，此时client处已经没有和server的连接了，所以client将会发送一个RST报文段给server，表明出现了一个错误。但是(1)处的send还是会调用成功的，由于收到了一个RST所以(2)处的send将会返回-1，表明发送失败，同时会触发一个SIGPIPE信号，这个信号默认的处理函数是终结进程，一般的话我们是选择忽略这个信号。<br>如果server调用读操作的话，由于已经关闭了连接，读操作一直会返回0，表明没有数据可读了。</p>
<h3 id="调用shutdown函数执行半关闭"><a href="#调用shutdown函数执行半关闭" class="headerlink" title="调用shutdown函数执行半关闭"></a>调用shutdown函数执行半关闭</h3><p>如果对一个连接的TCP调用shutdown执行半关闭的话  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shutdown(fd,SHUT_WR);</span><br></pre></td></tr></table></figure>
<p>那么由于只关闭了一端的通信管道，所以另一端仍然可以进行写操作。 </p>
<p><img src="/images/close_2.png" alt="对一个半关闭的连接执行读写操作">  </p>
<p>client执行了半关闭，这说明client发送了FIN报文段给server，并且server也发送了ACK报文段给client进行了确认，表明client到server的这一条通信管道已经关闭了。<br>server端(1)处的send能够调用成功，因为server发送数据给client是通过server到client这一条管道<br>，而这条管道并没有关闭，于此同时client(4)的recv也能正常接收数据，因为recv也是从server到client这条管道接收数据。server端(2)处的recv则会返回0，因为client到server管道已经关闭，已经没有数据可读了。client端(3)处的send写则会失败，因为client到server的写管道已经被关闭，不能进行写了，所以返回-1，并且触发一个SIGPIPE信号给client，默认处理是终结client进程。</p>
<h3 id="对处于半打开状态的连接执行读写操作"><a href="#对处于半打开状态的连接执行读写操作" class="headerlink" title="对处于半打开状态的连接执行读写操作"></a>对处于半打开状态的连接执行读写操作</h3><p>如果一方已经关闭或异常终止连接而另一方却还不知道，我们将这样的TCP连接成为半打开的。任何一端的主机异常都可能导致发生这种情况。只要不打算在版打开的连接上进行写操作，仍处于连接状态的一方就不会检测到另一方已经出现异常。<br>这其实很好理解。我们知道不管完整的关闭还是半关闭，都要发送FIN报文段，和确认ACK报文段。这就是通知对端该TCP连接关闭了，所以如果主机出现异常情况，在关闭的情况下却没有发送这些报文段，那么对端肯定不知道出现异常的主机已经关闭连接了，它还会认为连接在网络中是正常的。<br>出现半打开的情况最长见的情形就是当client端突然掉电而不是正常的结束client应用程序后再关机。如果一个server的很多client发生这种情况，那么就会出现很多半打开的TCP连接，而server一般不会主动写数据给client，所以也不会检查到错误发生了，这样server端的半打开TCP连接就会累积的越来越多(通过设置TCP的keeplive选项能够使TCP的一端发现另一段已经消失)。<br>如果client断电关机后重启，server端对这个半打开的TCP连接进行写数据到重启的client，由于client重启前的所以的连接信息都丢失了，client发送一个RST报文段给server，server端收到RST报文后将会终止连接了，TCP连接半打开的状态就不存在了。如果server只是对这个半打开的TCP连接进行读操作，那么server可能永远不会知道client端的TCP已经关闭了。</p>
<h3 id="RST报文"><a href="#RST报文" class="headerlink" title="RST报文"></a>RST报文</h3><p>RST表示复位，用来异常的关闭连接。发送RST报文关闭连接时，不必等缓存区中的包都发出去，直接就丢弃缓存区的包发送RST报文。而接收端在收到RST报文后，也不必发送ACK报文来确认。</p>
</div></article></div></main><footer><div class="paginator"><a href="/2018/07/07/processcontrol/" class="prev">PREV</a><a href="/2018/07/07/tcpwait/" class="next">NEXT</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'longxq-github-io';
var disqus_identifier = '2018/07/07/socketreadwrite/';
var disqus_title = 'TCP关闭后的读写总结';
var disqus_url = 'https://longxq.github.io/2018/07/07/socketreadwrite/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//longxq-github-io.disqus.com/count.js" async></script><div class="copyright"><p>© 2015 - 2018 <a href="https://longxq.github.io">龙雄球</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>