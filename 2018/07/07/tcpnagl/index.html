<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> TCP经受时延的确认算法和Nagle算法 · oooo</title><meta name="description" content="TCP经受时延的确认算法和Nagle算法 - 龙雄球"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://longxq.github.io/atom.xml" title="oooo"></head><body><div class="wrap"><header><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/LongXQ" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xm" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">TCP经受时延的确认算法和Nagle算法</h1><div class="post-info">Jul 7, 2018</div><div class="post-content"><p>TCP中这两个算法的目的都是为了减少在网络中的分组数目，减少网络的负载，特别是当小分组数目很多的时候。</p>
<h3 id="经受时延的确认"><a href="#经受时延的确认" class="headerlink" title="经受时延的确认"></a>经受时延的确认</h3><p>经受时延的确认(delayed<br>ACK)算法是当TCP在接收到数据的时候并不立即发送ACK确认给对端，相反，它推迟发送ACK，以便将ACK与要发送的数据一起发送给对端。当然这个推迟也不是无限推迟，在RFC中描述为推迟的时间一定要小于500ms。<br>这个算法的好处就是，当一方发送的分组都是一些小分组的时候，那么另一方就要频繁对小分组发送确认，而如果采用经受时延的确认，则确认就包含在了数据分组里面，减少了分组的数目。</p>
<h3 id="Nagle算法"><a href="#Nagle算法" class="headerlink" title="Nagle算法"></a>Nagle算法</h3><p>对于一些交互式的应用，经常发送一些只有一个或者几个字节的数据就要发送一个分组，那么一个分组中的有效数据就很少，更多的是一些额外的字节，如20字节的IP首部，20字节的TCP首部。这些额外的字节比有效的数据多得多，如果频繁发出这些小分组，那么很可能就会造成网络拥塞。一种简单和好的方法就是采用Nagle算法。<br>该算法要求一个TCP连接上最多只能有一个未被确认的未完成的小分组，在该分组的确认到达之前不能发送其他的小分组。相反，TCP会在确认到达之前，收集这期间要发送的少量的分组，并在确认到来时以一个分组的方式发送出去。<br>可以看到通过Nagle算法，可以节省很多网络带宽。特别是当确认到达的时间要很久的时候，说明这时候网络状况不是很好，而如果还继续频繁的发送小分组则更会造成网络拥塞，而如果采用Nagle算法，则可以收集小分组以一个大的分组形式一次发出，减少了要发送的分组的数量，节约了网络的带宽。</p>
<h3 id="TCP-NODELAY选项"><a href="#TCP-NODELAY选项" class="headerlink" title="TCP_NODELAY选项"></a>TCP_NODELAY选项</h3><p>我们经常在一些网络程序中看到这些代码:  </p>
<pre><code class="c"><span class="keyword">int</span> yes=<span class="number">1</span>;  
setsockopt(fd,IPPROTO_TCP,TCP_NODELAY,&amp;yes,siezof(yes)); 
</code></pre>
<p>这是设置socket选项的函数。其中TCP_NODELAY的作用就是关闭Nagle算法。当Nagle算法和经时延的确认算法在一起工作的时候，就要出一些问题了，此时我们要关闭Nagle算法。<br>关闭Nagle算法的目的很明显就是要当有要发送的分组，不管分组是大还是小，应该立即发送出去，不管前面有没有未被确认的分组。<br>我们先看下当这两种算法同时作用的情况：  </p>
<p><img src="/images/nagle.png" alt="经时延的确认和Nagle算法">  </p>
<p>上面是一个client和server交互的情形，client发送数据给server，然后server并不马上发送确认回去，而是等待自己要有数据发送了在和确认一起发送给client(经时延的确认)。同时client端在等待第一个数据的确认的期间，也不发送数据给server(Nagle)，而是收集这些数据数据，直到收到确认后再一个大分组的形式发送给server，当然其中也包括了对server端数据的确认。<br>这看起来好像并没有什么问题，但是现实中兵不是所有的数据流都是这样的。在来看看下面这种client和server的交互数据流：  </p>
<p><img src="/images/nagle_2.png" alt="要关闭Nagle算法的情况"></p>
<p>从上面我们可以看到矛盾的地方：server端要求更多的数据才能工作，而client端由于Nagle算法的原因在没收到第一个数据的确认并不会马上发送数据给server，而此时server正在等待更多的数据，才会产生数据给client，所以第一个数据的确认只能等待超出经延迟确认算法的延迟时间后，才会发送给client。<br>所以可以看到当碰到这种交互的时候，会发生这种情况，server端等待进一步的数据到达才会产生数据，并和确认发送给client，而client由于Nagle算法，由于没有收到确认却迟迟不发送更多的数据给server。那么这样会造成client每次发送数据都要推迟经时延的确认算法规定的时延这么多时间才会发送出去。很明显这是不能忍受的，所以我们有时候要关闭Nagle算法，不必等候前一个分组的确认就把数据发送出去<br>。(把这种交互叫做Write-Write-Read模式，因为client至少发送两个分组数据才会从server端读一次数据)</p>
</div></article></div></main><footer><div class="paginator"><a href="/2018/07/07/tcpconnect/" class="prev">PREV</a><a href="/2018/07/07/sigpipe/" class="next">NEXT</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'longxq-github-io';
var disqus_identifier = '2018/07/07/tcpnagl/';
var disqus_title = 'TCP经受时延的确认算法和Nagle算法';
var disqus_url = 'https://longxq.github.io/2018/07/07/tcpnagl/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//longxq-github-io.disqus.com/count.js" async></script><div class="copyright"><p>© 2015 - 2018 <a href="https://longxq.github.io">龙雄球</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>