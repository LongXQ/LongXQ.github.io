<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> oooo</title><meta name="description" content="A Blog Powered By Hexo"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://longxq.github.io/atom.xml" title="oooo"></head><body><div class="wrap"><header><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link active">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/LongXQ" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xm" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><ul class="home post-list"><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2018/07/07/cexception/" class="post-title-link">c++异常机制</a></h2><div class="post-info">Jul 7, 2018</div><div class="post-content"><p>c++异常机制包括三个部分:异常抛出，异常捕获处理，和栈回退。<br>其中栈回退主要是用来确保在异常被抛出，捕获并处理后，所有生命期已结束的对象都会被正确地析构，他们所占用的空间会被正确地回收。</p></div><a href="/2018/07/07/cexception/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2018/07/07/signal/" class="post-title-link">signal</a></h2><div class="post-info">Jul 7, 2018</div><div class="post-content"><h3 id="信号的状态"><a href="#信号的状态" class="headerlink" title="信号的状态"></a>信号的状态</h3><p>当一个信号产生时，内核通常在进程表中以某种形式设置一个标志。当对信号采取了这种时，我们说向进程递送了一个信号。在信号产生和递送之间的时间间隔内，该信号是未决的(pending)。<br>如果该信号被阻塞了，而且对该信号的动作是系统默认或捕捉该信号，则为该进程将此信号保持为未决状态，直到该进程对该信号解除阻塞或者将对次信号的动作更改为忽略。如果对该处于未决状态的信号解除了阻塞而且对该信号的动作不是忽略，那么该信号就会被递送给进程。进程是在信号递送给它时决定对它的处理方式，所以在信号递送之前任然可以改变对该信号的处理动作，这也是前面说到的对处于未决状态的信号我们仍然可以更改该信号的动作为忽略。</p></div><a href="/2018/07/07/signal/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2018/07/07/pid/" class="post-title-link">Linux用户id</a></h2><div class="post-info">Jul 7, 2018</div><div class="post-content"></div><a href="/2018/07/07/pid/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2018/07/07/processcontrol/" class="post-title-link">进程控制</a></h2><div class="post-info">Jul 7, 2018</div><div class="post-content"><h3 id="进程组"><a href="#进程组" class="headerlink" title="进程组"></a>进程组</h3><p>每一个进程除了有一进程ID之外，还属于一个进程组。<br>进程组是一个或多个进程的集合。通常，它们是同一作业中结合起来的，同一进程组中的各进程接收来自同一个终端的各种信号。每一个进程组有一个唯一的进程组ID。<br>每一个进程组有一个组长进程，进程组ID等于其进程ID。<br>进程组组长可以创建一个进程组，创建该组中的进程，然后终止。只要在某个进程组中有一个进程存在，则该进程组就存在，这与其组长进程是否终止无关。<br>从进程组创建开始到其中最后一个进程离开为止的时间区间称为进程组的生命期。<br>某个进程组中的最后一个进程可以终止，也可以转移到另一个进程组。</p></div><a href="/2018/07/07/processcontrol/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2018/07/07/socketreadwrite/" class="post-title-link">TCP关闭后的读写总结</a></h2><div class="post-info">Jul 7, 2018</div><div class="post-content"><p>一个TCP连接，相当于建立两条独立的通信管道，两端可以进行全双工通信，能够进行读和写。</p>
<p><img src="/images/TCP连接.jpg" alt="一个TCP连接"></p></div><a href="/2018/07/07/socketreadwrite/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2018/07/07/tcpwait/" class="post-title-link">TIME_WAIT状态</a></h2><div class="post-info">Jul 7, 2018</div><div class="post-content"><p>TCP连接是全双工连接，类似于下面：  </p>
<p><img src="/images/time_wait.png" alt="TCP全双工连接">  </p>
<p>上图中表示主机A和B通过TCP建立了全双工连接，也就是任意一端都可以发送和接收数据。<br>当主机A和B建立成功后，A和B就处于ESTABLISHED状态了。当一端主动调用close系统调用来关闭TCP连接，系统就处于关闭阶段了：  </p>
<p><img src="/images/time_wait1.png" alt="关闭TCP连接"></p></div><a href="/2018/07/07/tcpwait/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2018/07/07/connect/" class="post-title-link">非阻塞connect</a></h2><div class="post-info">Jul 7, 2018</div><div class="post-content"><p>对一个非阻塞TCP套接字调用connect，那么这个connect就变成了非阻塞的connect。<br>当调用非阻塞connect，connect将立即返回一个EINPROGRESS错误，不过已经发起的TCP三鹿握手继续进行。这么做的好处首先就是在TCP三次握手阶段，进程不用一直阻塞在connect系统调用上，进程可以暂时做些其他事情，connect相当于发起了连接的作用。那么我们怎么知道TCP连接成功建立了呢？</p>
<ol>
<li>尽管TCP套接字是非阻塞的，如果连接到的服务器在同一主机上，那么当我们调用connect时，连接通常立刻建立。connect会返回0，表明连接立即建立成功了。</li>
<li>对于连接不能立即建立的，我们可以在后续的过程通过一些I/O复用函数来知道连接是否成功还是出错了，如select，epoll。当连接成功建立时，描述符变为可写。当连接建立遇到错误时，描述符变为既可读又可写。 </li>
</ol>
<p>但是我们要需要特别注意的是：<br>当一个TCP成功建立，并且对端已经发送了一些数据来的时候也会使得非阻塞套接字变得可读可写。非阻塞套接字连接出错也会使得套接字变得可读可写。所以当一个非阻塞TCP套接字变得可读可写的时候，我们需要通过调用getsockopt获取SO_ERROR的值来检查套接字上是否存在待处理错误来处理这种情形。<br>除了调用getsockopt来获取套接字的错误可以判断套接字是否建立成功，还可以用如下方法； </p>
<p><img src="/images/connect.png" alt="其他方法判定非阻塞connect连接成功"></p></div><a href="/2018/07/07/connect/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2018/07/07/ipv4ipv6/" class="post-title-link">ipv4ipv6</a></h2><div class="post-info">Jul 7, 2018</div><div class="post-content"><p>下面成立的条件是主机是双栈主机，也就是同时支持IPv4协议和IPv6协议。<br>双栈主机上的IPv6服务器既能够服务于IPv4客户，又能够服务于IPv6客户。IPv4客户发送给这种服务器的仍然是IPv4数据报，不过服务器的协议栈会把客户主机的地址转换成一个IPv4的映射的IPv6地址，因此IPv6服务器仅仅处理IPv6套接字地址结构。<br>类似地，双栈主机上的IPv6客户能够和IPv4服务器通信。客户的解析器会把服务器主机所有的A记录作为IPv4映射的IPv6地址返回给客户，而客户指定这些地址之一调用connect将会使双栈发送一个IPv4<br>SYN分节。<br>IN6_IS_ADDR_V4MAPPED宏可用于判定对端是否在使用IPv4.</p></div><a href="/2018/07/07/ipv4ipv6/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2018/07/07/bigend/" class="post-title-link">大端和小端字节序</a></h2><div class="post-info">Jul 7, 2018</div><div class="post-content"><p>考虑存储一个2个字节的整数。内存中存储这两个字节有两种方法：一种是将低序字节存储在起始地址，这称为小端(litter-<br>endian)字节序；另一种方法是将高序字节存储在起始地址，这成为大端(big-endian)字节序。  </p>
<p><img src="/images/byteorder.png" alt="2个字节的整数小端和大端字节序存储">  </p>
<p>我们把某个给定系统所用的字节序成为主机字节序(host byte<br>order)。对于不同的系统来说，他们的字节序都有可能不同。网络传输数据的时候，也必须指定一个字节序，网络传输采用大端字节序来传送数据。所以在主机和网络中交换数据要进行字节序的转换。<br>在linux系统中定义了一系列函数用来在网络和主机之间的字节序的转换函数。  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;  </span></span></span><br><span class="line"><span class="keyword">uint16_t</span> htons(<span class="keyword">uint16_t</span> hostshort);  </span><br><span class="line"><span class="keyword">uint32_t</span> htonl(<span class="keyword">uint32_t</span> hostlong);  </span><br><span class="line"><span class="keyword">uint16_t</span> ntohs(<span class="keyword">uint16_t</span> netshort);  </span><br><span class="line"><span class="keyword">uint32_t</span> ntohl(<span class="keyword">uint32_t</span> netlong);</span><br></pre></td></tr></table></figure></div><a href="/2018/07/07/bigend/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2018/07/07/tcpconnect/" class="post-title-link">TCP连接队列</a></h2><div class="post-info">Jul 7, 2018</div><div class="post-content"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">listen(fd,BACKLOG);</span><br></pre></td></tr></table></figure>
<p>listen函数建立了一个监听接口，其中BACKLOG参数指明了TCP已完成连接队列上的连接数。<br>监听接口一端中已完成连接队列上的连接是已被TCP接受的连接(三次握手成功，即TCP连接处于ESATABLISHED状态)，但还没有被应用层所接受(accept)。<br>特别注意的是TCP接受一个连接是将其放入已完成连接队列上，而应用层接受连接时将其从已完成连接队列中移出。<br>对于新的连接请求，该TCP监听接口的端点的连接队列中还要空间，则把完成的TCP连接放入该队列。<br>应用层调用accept函数从队列中获取成功连接的TCP连接，队列中以连接数目减一。<br>特别注意的是，当连接队列已满时，但是还有连接请求到达时，那么TCP是怎么处理的？<br>我在Linux机器上测试的结果是：当队列已满，但是还有新的连接请求到达时，TCP会自动把队列中的已完成的连接移出，空出空间来给新的连接。<br>最后要注意的是，实际中队列的长度等于BACKLOG的值加一，这可能是考虑了当BACKLOG为0的情况，也就是队列中能够容纳的连接数目至少为1.</p></div><a href="/2018/07/07/tcpconnect/" class="read-more">...more</a></article></li></ul></main><footer><div class="paginator"><a href="/page/2/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2018 <a href="https://longxq.github.io">龙雄球</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>