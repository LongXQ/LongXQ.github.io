<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> TIME_WAIT状态 · oooo</title><meta name="description" content="TIME_WAIT状态 - 龙雄球"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://longxq.github.io/atom.xml" title="oooo"></head><body><div class="wrap"><header><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/LongXQ" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xm" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">TIME_WAIT状态</h1><div class="post-info">Jul 7, 2018</div><div class="post-content"><p>TCP连接是全双工连接，类似于下面：  </p>
<p><img src="/images/time_wait.png" alt="TCP全双工连接">  </p>
<p>上图中表示主机A和B通过TCP建立了全双工连接，也就是任意一端都可以发送和接收数据。<br>当主机A和B建立成功后，A和B就处于ESTABLISHED状态了。当一端主动调用close系统调用来关闭TCP连接，系统就处于关闭阶段了：  </p>
<p><img src="/images/time_wait1.png" alt="关闭TCP连接"></p>
<a id="more"></a>
<p>我们忽略了关闭过程中的中间一些状态。<br>主动关闭一方最后处于TIME_WAIT状态的时间一般为2MSL。MSL是最长分节生命，也就是一个IP数据报在网络中能够生存的最长时间。为了解释为什么TIME_WAIT状态时间为2MSL，而不是MSL或者当发送完最后一个ACK立马就关闭成功，我们假设下面两种情况。</p>
<ol>
<li>对端没有成功接收最后一个ACK，那么对端就会认为它前面发送的FIN报文对端没有成功接收，那么它就会重发FIN报文，然后继续等待ACK。我们算下重发FIN报文到对端接收重发的FIN报文要多久时间。首先主动关闭一方发送ACK，那么ACK报文最长的生存时间为MSL，当对端到一个报文的最长生命周期内还没有收到ACK报文，它肯定就是重发FIN报文，那么FIN报文传送过来的最长时间也是MSL，所以为了确保最后一个ACK成功发送给了对端，TIME_WAIT状态的持续时间为2MSL。</li>
<li>当最后一个ACK报文对端成功接收后，算是关闭成功了，但是有可能对端在收到最后一个ACK报文前，它前面发送的一些数据还没有到达对方，那么就会出现一些问题。假如我们close调用后，马上又建立一个和前面一样的TCP连接，那么这部分后达到的数据就会被新建立的TCP连接接收到，这很明显是错误的，所以关闭一个TCP连接时，还要有一个TIME_WAIT状态保证该TCP连接阶段所有的数据都在网络中不存在了，因为我们知道TIME_WAIT持续的时间为2MSL，那么在这段时间内，和该TCP连接有关的所有数据肯定都会消亡的。这样就不会被新建的TCP连接接收到了。</li>
</ol>
<p>上面的情况2要成立，要保证地址不能复用，就是当一个地址处于TIME_WAIT状态的时候，新建一个socket的地址不能和它一样。系统默认就是这样处理，但是我们也可以关闭这个，允许地址可以复用，也就是处于TIME_WAIT状态的地址可以被新建的socket复用，只要设置SO_REUSEADDR选项就可以了，但是如果这样就不能完全保证上面的情况2了。</p>
<p>从上面看到，close系统调用时关闭了两端，但是很多情况下，我们只想关闭一端，而允许另外一端接着发送数据：<br><img src="/images/time_wait2.png" alt="单通道关闭"><br>从图中可以看到我们只关闭了A端的写入口，当关闭了A端后，如果B还要读，那么会接收到FIN，表明已经没有数据可以读了。但是B端还可以进行写，A端还可以从B端接收数据。<br>我们用shutdown系统调用可以实现上面的功能。  </p>
<pre><code class="c"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;  </span></span>
<span class="function"><span class="keyword">int</span> <span class="title">shutdown</span><span class="params">(<span class="keyword">int</span> sockfd,<span class="keyword">int</span> howto)</span></span>;  
</code></pre>
<p>howto可以为SHUTRD,SHUT_WR,SHUTRDWE，分别为关闭sockfd的读端，写端，读写端(和close一样)。<br>当关闭一个socket的读端后，接收缓冲区里面的数据全都被丢弃，以后不能调用任何读函数了。但是该socket还是可以接收对端发送来的数据并发送确认，但是之后不会交给进程，而是会悄然丢弃掉。从这里我们可以看到关闭写端并没有实质的进行关闭，也就是不会发送FIN之类的给对端，所以对端还能正常发送数据。</p>
<p>从上面可以看到一个成功的关闭要包含发送FIN，接收ACK这过程，也就是说如果没有包含这一个过程就算异常退出。<br>如果一端程序突然奔溃或者关闭阶段某一步出现错误，如果对方继续读写对端，会导致奔溃的一端TCP发送RST重置连接，表明出现了错误重置。对于写则还会抛出一个SIGPIPE异常的</p>
</div></article></div></main><footer><div class="paginator"><a href="/2018/07/07/socketreadwrite/" class="prev">PREV</a><a href="/2018/07/07/connect/" class="next">NEXT</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'longxq-github-io';
var disqus_identifier = '2018/07/07/tcpwait/';
var disqus_title = 'TIME_WAIT状态';
var disqus_url = 'https://longxq.github.io/2018/07/07/tcpwait/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//longxq-github-io.disqus.com/count.js" async></script><div class="copyright"><p>© 2015 - 2018 <a href="https://longxq.github.io">龙雄球</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>