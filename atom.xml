<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>oooo</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://longxq.github.io/"/>
  <updated>2018-07-07T14:13:10.155Z</updated>
  <id>https://longxq.github.io/</id>
  
  <author>
    <name>龙雄球</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Redis ziplist实现</title>
    <link href="https://longxq.github.io/2018/07/07/ziplist/"/>
    <id>https://longxq.github.io/2018/07/07/ziplist/</id>
    <published>2018-07-07T14:08:49.456Z</published>
    <updated>2018-07-07T14:13:10.155Z</updated>
    
    <content type="html"><![CDATA[<p>ziplist结构是Redis内部用来实现REDIS_ENCODING_ZIPLIST对象编码的。</p><h3 id="ziplist结构分析"><a href="#ziplist结构分析" class="headerlink" title="ziplist结构分析"></a>ziplist结构分析</h3><p>首先我们从总体上来看下ziplist结构的总体布局:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">zlbytes</span>&gt;</span><span class="tag">&lt;<span class="name">zltail</span>&gt;</span><span class="tag">&lt;<span class="name">zllen</span>&gt;</span><span class="tag">&lt;<span class="name">entry</span>&gt;</span><span class="tag">&lt;<span class="name">entry</span>&gt;</span>...<span class="tag">&lt;<span class="name">entry</span>&gt;</span><span class="tag">&lt;<span class="name">zlend</span>&gt;</span></span><br></pre></td></tr></table></figure><p>接着看看ziplist中每一个部分的作用.</p><h3 id="ziplist的头部"><a href="#ziplist的头部" class="headerlink" title="ziplist的头部"></a>ziplist的头部</h3><pre><code class="html"><span class="tag">&lt;<span class="name">zlbytes</span>&gt;</span><span class="tag">&lt;<span class="name">zltail</span>&gt;</span><span class="tag">&lt;<span class="name">zllen</span>&gt;</span>  </code></pre><p>一起组成了ziplist的头部部分。这三部分描述了一个ziplist结构的总体信息:</p><ol><li><code>&lt;zlbytes&gt;</code>是一个unsigned integer，表示ziplist所占用的字节数大小。</li><li><code>&lt;zltail&gt;</code>表示到最后一个entry的字节偏移量。有了这个字段我们就能很快定位到最后一个entry</li><li><code>&lt;zllen&gt;</code>代表了当前ziplist中有多少个entry。</li></ol><h3 id="lt-entry-gt-部分"><a href="#lt-entry-gt-部分" class="headerlink" title="&lt;entry&gt;部分"></a><code>&lt;entry&gt;</code>部分</h3><p>一个<code>&lt;entry&gt;</code>就代表了ziplist中的一个元素。如果一个ziplist中没有一个元素，说明此时ziplist是一个空的，不存在任何数据。大于等于0个<code>&lt;entry&gt;</code>构成了ziplist的主体部分。下面来看看<code>&lt;entry&gt;</code>结构是个什么样子。<br>特别注意的是<code>&lt;entry&gt;</code>的大小不是固定不变的，不同的<code>&lt;entry&gt;</code>它的大小有可能是不一样的。下面是<code>&lt;entry&gt;</code>的结构:  </p><p><img src="/images/ZiplistEntry.png" alt="entry结构"> </p><p>首先<code>&lt;entry&gt;</code>的header中的第一部分表示前一个的大小。这一部分的长度不是固定的，根据前一个<code>&lt;entry&gt;</code>的大小的不同而不同:</p><ol><li>如果前一个<code>&lt;entry&gt;</code>的大小小于254字节，那么这一部分就占用一个字节的大小来表示前一个<code>&lt;entry&gt;</code>的大小</li><li>如果前一个<code>&lt;entry&gt;</code>的大小大于或者等于254个字节，那么这一部分就占用5个字节来表示前一个<code>&lt;entry&gt;</code>的大小。其中第一个字节被设置成254，用来表明接下来要用4个字节来表达前一个<code>&lt;entry&gt;</code>的大小。</li></ol><p>在来看看<code>&lt;entry&gt;</code>的header中第二部分。这一部分是<code>&lt;entry&gt;</code>的类型和大小编码。用来描述这个<code>&lt;entry&gt;</code>数据部分存储的是一串字符串还是一个整数，并描述了<code>&lt;entry&gt;</code>数据部分用来存储这些数据所占用的字节数大小。</p><h3 id="当数据部分是一串字符串的时候"><a href="#当数据部分是一串字符串的时候" class="headerlink" title="当数据部分是一串字符串的时候"></a>当数据部分是一串字符串的时候</h3><ol><li>|00pppppp| - 当数据部分是一串字符串且大小小于或等于63个字节的时候，该部分占用1一个字节。前2个比特位设置成00，后面的6个比特位用来描述数据部分的大小</li><li>|01pppppp|qqqqqqqq| - 当数据部分是一串字符串且大小小于或者等于16383字节(14个比特位表示)的时候，该部分占用2个字节的大小，前2个比特位被设置成01，后面的14个比特位描述数据部分的大小。</li><li>|10 <strong>__</strong> |qqqqqqqq|rrrrrrrr|ssssssss|tttttttt| - 当数据部分是一串字符串的时候并且大小大于或者等于16384字节的时候，该部分占用5个字节大小，前2个比特位被设置成10，后4个字节用来描述数据部分的大小。</li></ol><h5 id="当数据部分是整数的时候"><a href="#当数据部分是整数的时候" class="headerlink" title="当数据部分是整数的时候"></a>当数据部分是整数的时候</h5><p>当数据部分是一个整数的时候，该部分只占用了1个字节的大小。其中前2个比特位被设置成11，表示<code>&lt;entry&gt;</code>的数据部分是一个整数。后6个比特位用来表示该整数占用的字节数。</p><ol start="4"><li>|11000000| - 表明数据部分占用了2个字节，存储的是一个int16_t类型的整数</li><li>|11010000| - 表明数据部分占用了4个字节，存储的是一个int32_t类型的整数</li><li>|11100000| - 表明数据部分占用了8个字节，存储的是一个int64_t类型的整数</li><li>|11110000| - 表明数据部分占用了3个字节，存储的是一个24比特位的整数</li><li>|11111110| - 表明数据部分占用了1个字节，存储的是8比特位的整数</li><li>|1111xxxx| - 此时该<code>&lt;entry&gt;</code>无数据部分。当存储的整数是0~12的时候，直接用该部分的后4个比特位来表示。因为后4个比特位不能为0000和1110和1111，所以xxxx能够表示的范围为0001~1101，也就是能够表示的整数位1~13，但是我们要表示的是整数范围是0~12，所以为了取得正确的值，记得要进行减一操作。</li></ol><h3 id="lt-zlend-gt"><a href="#lt-zlend-gt" class="headerlink" title="&lt;zlend&gt;"></a><code>&lt;zlend&gt;</code></h3><h2 id="lt-zlend-gt-是ziplist的尾部，它占用一个字节，被固定设置成255，用来表示该位置是ziplist的结束部分了。"><a href="#lt-zlend-gt-是ziplist的尾部，它占用一个字节，被固定设置成255，用来表示该位置是ziplist的结束部分了。" class="headerlink" title="&lt;zlend&gt;是ziplist的尾部，它占用一个字节，被固定设置成255，用来表示该位置是ziplist的结束部分了。"></a><code>&lt;zlend&gt;</code>是ziplist的尾部，它占用一个字节，被固定设置成255，用来表示该位置是ziplist的结束部分了。</h2><h3 id="Redis-list类型"><a href="#Redis-list类型" class="headerlink" title="Redis list类型"></a>Redis list类型</h3><p>接下来我们看看Redis list类型的数据怎么用ziplist来实现REDIS_ENCODING_ZIPLIST对象编码的。<br>假如一个list对象由三个元素组成:valxxx…xxx56,valxxx…xxx256,10,65530。第一个元素是大小为56个字节的字符串，第二个元素是大小为256的字符串，第三个和第四个元素都是整数。我们看看怎么用REDIS_ENCODING_ZIPLIST对象编码来存储的。  </p><p><img src="/images/REDIS_ENCODING_ZIPLIST.png" alt="REDIS_ENCODING_ZIPLIST">  </p><p>再来看看一个完整的使用了REDIS_ENCODING_ZIPLIST对象编码的Redis list对象的结构:  </p><p><img src="/images/redis_list_1.png" alt="REDIS_LIST"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;ziplist结构是Redis内部用来实现REDIS_ENCODING_ZIPLIST对象编码的。&lt;/p&gt;
&lt;h3 id=&quot;ziplist结构分析&quot;&gt;&lt;a href=&quot;#ziplist结构分析&quot; class=&quot;headerlink&quot; title=&quot;ziplist结构分析&quot;&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Redis dynamic strings</title>
    <link href="https://longxq.github.io/2018/07/07/redis2/"/>
    <id>https://longxq.github.io/2018/07/07/redis2/</id>
    <published>2018-07-07T12:06:59.629Z</published>
    <updated>2018-07-07T14:07:53.772Z</updated>
    
    <content type="html"><![CDATA[<p>在讲述其他Redis类型和对象编码前，我们先来看看Redis中最简单的类型String。<br>String是Redis诸多类型中最基本的类型，它是lists，hashes，sets等类型的基本组成部分。<br>我们知道Redis是以key-value方式存储的。所有的Redis keys都是string类型，同时string也是最简单的value类型。<br>接下来我们看看string类型在Redis中是怎么实现的。</p><a id="more"></a><h2 id="Redis-string的实现"><a href="#Redis-string的实现" class="headerlink" title="Redis string的实现"></a>Redis string的实现</h2><p>一个C结构sdshdr代表一个Redis string: </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span>&#123;</span>  </span><br><span class="line">    <span class="keyword">long</span> len;  </span><br><span class="line">    <span class="keyword">long</span> <span class="built_in">free</span>;  </span><br><span class="line">    <span class="keyword">char</span> buf[];  </span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><p>所以我们看到string类型的实现在Redis内部就是一个sdshdr类型。buf字符数组存储真实的字符串数据。len字段存储着buf的长度。free字段存储的buf数组中目前还有多少可用字节。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> *sds;</span><br></pre></td></tr></table></figure><p>在Redis内部还定义了一个sds类型，其实就是一个字符串指针。一个sds对象就是一个指针，这个指针指向一个sdshdr对象的buf部分，也就是Redis<br>string对象的实际数据部分。<br>假设我们新建了一个内容为”hello,world”字符串的redis string，我们来看看他们redis内部是怎么表示的:<br><img src="/images/String.png" alt="Redis string"><br>可以看到stringObj就是一个string对象，p是一个sds对象，指向了stringObj的buf部分。在实际中，我们不直接使用一个string对象，而是间接的使用sds对象来操作string对象，毕竟我们只需要string对象中的真实数据。</p><h2 id="Redis-string类型的对象编码"><a href="#Redis-string类型的对象编码" class="headerlink" title="Redis string类型的对象编码"></a>Redis string类型的对象编码</h2><p>String类型的对象有三种编码方式:  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ENCODING_RAW 0  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ENCODING_INT 1  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ENCODING_EMBSTR 8</span></span><br></pre></td></tr></table></figure><p>首先我们看第一种编码方式。</p><h3 id="REDIS-ENCODING-RAW"><a href="#REDIS-ENCODING-RAW" class="headerlink" title="REDIS_ENCODING_RAW"></a>REDIS_ENCODING_RAW</h3><p>REDIS_ENCODING_RAW编码方式很简单，其实就是把一个sds对象赋值给robj对象的ptr指针。<br>我们来看看Redis内部是怎么以REDIS_ENCODING_RAW编码方式来存储string对象的:</p><ol><li>首先新建一个robj对象，然后把type设置为REDIS_STRING，把encoidng设置为REDIS_ENCODING_RAW:</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">robj *stringObj=<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(robj));  </span><br><span class="line">    stringObj-&gt;type=REDIS_STRING;  </span><br><span class="line">    stringObj-&gt;encoidng=REDIS_ENCODING_RAW;</span><br></pre></td></tr></table></figure><ol start="2"><li><p>然后新建一个sdshdr对象sh和sds对象p，把实际的数据存储到sh中，并把buf赋值给p。</p></li><li><p>把上面新建的sds对象赋值给stringObj的ptr指针。</p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stringObj-&gt;ptr=p;</span><br></pre></td></tr></table></figure><p><img src="/images/REDIS_ENCODING_RAW.png" alt="REDIS_ENCODING_RAW"></p><h3 id="REDIS-ENCODING-INT"><a href="#REDIS-ENCODING-INT" class="headerlink" title="REDIS_ENCODING_INT"></a>REDIS_ENCODING_INT</h3><p>当一串字符串可以转换成整数时候，就用REDIS_ENCODING_INT编码方式来存储这串字符串，这种编码方式是先把字符串转换成整数，然后直接赋值给robj对象的ptr指针，这样就节省了sdshdr结构所占用的内存，而且数据部分也节省了很多内存，以字符串”123456789123456789”为例:</p><ol><li>首先新建了一个robj对象o。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">o-&gt;type=REDIS_STRING;  </span><br><span class="line">o-&gt;encoidng=REDIS_ENCOIDNG_INT;</span><br></pre></td></tr></table></figure><ol start="2"><li>然后把字符串转换成整数p，以”123456789123456789”为例就是:</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> p=<span class="number">123456789123456789</span>;</span><br></pre></td></tr></table></figure><ol start="3"><li>直接把p赋值给o-&gt;ptr，而不是新建sdshdr对象:</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">o-&gt;ptr=(<span class="keyword">void</span>*)p;</span><br></pre></td></tr></table></figure><p><img src="/images/REDIS_ENCODING_INT.png" alt="REDIS_ENCODING_INT">  </p><p>我们可以看到这样可以节省很多内存。</p><h3 id="REDIS-ENCODING-EMBSTR"><a href="#REDIS-ENCODING-EMBSTR" class="headerlink" title="REDIS_ENCODING_EMBSTR"></a>REDIS_ENCODING_EMBSTR</h3><p>顾名思义这种编码方式就是把sdshdr对象内嵌到robj对象中，使他们形成一个整体。  </p><p><img src="/images/REDIS_ENCODING_EMBSTR.png" alt="REDIS_ENCODING_EMBSTR"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在讲述其他Redis类型和对象编码前，我们先来看看Redis中最简单的类型String。&lt;br&gt;String是Redis诸多类型中最基本的类型，它是lists，hashes，sets等类型的基本组成部分。&lt;br&gt;我们知道Redis是以key-value方式存储的。所有的Redis keys都是string类型，同时string也是最简单的value类型。&lt;br&gt;接下来我们看看string类型在Redis中是怎么实现的。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>redis对象系统</title>
    <link href="https://longxq.github.io/2018/07/07/redis1/"/>
    <id>https://longxq.github.io/2018/07/07/redis1/</id>
    <published>2018-07-07T10:27:59.830Z</published>
    <updated>2018-07-07T13:57:42.539Z</updated>
    
    <content type="html"><![CDATA[<p>redis是什么？移步<a href="www.redis.io">redis官网</a>。<br>redis支持的数据结构类型有很多，从简单的strings，到hashes，lists，sets，sorted<br>sets等。那么redis内部是怎么组织数据的呢？本文的目的就是梳理redis内部数据结构的实现方式，看看数据在redis内部是怎么存储的。</p><a id="more"></a><h3 id="redis对象"><a href="#redis对象" class="headerlink" title="redis对象"></a>redis对象</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span>&#123;</span>  </span><br><span class="line"><span class="keyword">unsigned</span> type:<span class="number">4</span>;  </span><br><span class="line"><span class="keyword">unsigned</span> encoding:<span class="number">4</span>;  </span><br><span class="line"><span class="keyword">unsigned</span> lru:REDIS_LRU_BITS;    <span class="comment">/* 和LRU算法相关的字段(先可以不关注这个字段) */</span>  </span><br><span class="line"><span class="keyword">int</span> refcount;    <span class="comment">/* 引用次数，因为一个对象可能会被共享 */</span>  </span><br><span class="line"><span class="keyword">void</span> *ptr;  </span><br><span class="line">&#125;robj;</span><br></pre></td></tr></table></figure><p>一个redis对象就是一个robj对象。  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_STRING 0  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_LIST 1  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_SET 2  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ZSET 3  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_HASH 4</span></span><br></pre></td></tr></table></figure><p>假如我们在一个robj对象内存储的是数据结构类型为string的对象，那么type就是REDIS_STRING，表示这个robj对象代表一个string类型的对象，而实际的这个string类型的对象由robj结构体中的ptr指针指向。假如是一个list对象，那么type字段的就是REDIS_LIST，表示这个robj对象代表一个list类型的对象，而实际的这个list类型的对象由ptr指针指向。</p><h3 id="对象编码"><a href="#对象编码" class="headerlink" title="对象编码"></a>对象编码</h3><p>现在我们要新建一个由val1，val2和val3组成的list。那么redis是如何实现的呢？首先当然是创建一个robj对象，并且把type赋值为REDIS_LIST，引用计数设置为1。  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">robj *listObj=<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(robj));  </span><br><span class="line">listObj-&gt;type=REDIS_LIST;  </span><br><span class="line">listObj-&gt;ref=<span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>那么redis内部是怎么表示这个由val1,val2,val3组成的list的呢？常规的方法可能是下面这样组织的:<br><img src="/images/list1.png" alt="list1"><br>我们也可以以数组的形式存储这个list:<br><img src="/images/list2.png" alt="list2"><br>这两种构造list的方式就是两种针对list类型对象的编码。对象的编码其实就是数据的组织方式，比如这里的list对象的数据组织既可以用链表的形式组织，也可以用数组的形式组织。为了知道当前对象是怎么编码的，我们把编码的代号赋值给robj结构的encoding字段。我们把第一种编码叫做NORMAL_LIST，第二种叫做ARRAY_LIST。当然redis内部是没有这两种编码的，在这里只是为了解释什么是对象编码。下面就是redis目前支持的编码种类，这些编码方式都是结合了性能和存储效率这两方面的。  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ENCODING_RAW 0    <span class="comment">/* Raw representation */</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ENCODING_INT 1    <span class="comment">/* 编码为整数 */</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ENCODING_HT 2     <span class="comment">/* 编码为hash table */</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ENCODING_ZIPMAP 3    <span class="comment">/* 编码为zipmap */</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ENCODING_LINKEDLIST 4    <span class="comment">/* 编码为普通的linked list */</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ENCODING_ZIPLIST 5    <span class="comment">/* 编码为ziplist */</span>      </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ENCODING_INTSET 6    <span class="comment">/* 编码为intset */</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ENCODING_SKIPLIST 7    <span class="comment">/* 编码为skiplist */</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ENCODING_EMBSTR 8    <span class="comment">/*编码为嵌入的sds string */</span></span></span><br></pre></td></tr></table></figure><p>接下来的一系列文章都会一一讲解这些编码方式，看看redis内部是怎么实现对象的存储的</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;redis是什么？移步&lt;a href=&quot;www.redis.io&quot;&gt;redis官网&lt;/a&gt;。&lt;br&gt;redis支持的数据结构类型有很多，从简单的strings，到hashes，lists，sets，sorted&lt;br&gt;sets等。那么redis内部是怎么组织数据的呢？本文的目的就是梳理redis内部数据结构的实现方式，看看数据在redis内部是怎么存储的。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
