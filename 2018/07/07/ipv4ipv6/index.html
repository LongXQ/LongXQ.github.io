<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> ipv4ipv6 · oooo</title><meta name="description" content="ipv4ipv6 - 龙雄球"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://longxq.github.io/atom.xml" title="oooo"></head><body><div class="wrap"><header><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/LongXQ" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xm" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">ipv4ipv6</h1><div class="post-info">Jul 7, 2018</div><div class="post-content"><p>下面成立的条件是主机是双栈主机，也就是同时支持IPv4协议和IPv6协议。<br>双栈主机上的IPv6服务器既能够服务于IPv4客户，又能够服务于IPv6客户。IPv4客户发送给这种服务器的仍然是IPv4数据报，不过服务器的协议栈会把客户主机的地址转换成一个IPv4的映射的IPv6地址，因此IPv6服务器仅仅处理IPv6套接字地址结构。<br>类似地，双栈主机上的IPv6客户能够和IPv4服务器通信。客户的解析器会把服务器主机所有的A记录作为IPv4映射的IPv6地址返回给客户，而客户指定这些地址之一调用connect将会使双栈发送一个IPv4<br>SYN分节。<br>IN6_IS_ADDR_V4MAPPED宏可用于判定对端是否在使用IPv4.</p>
<a id="more"></a>
<h3 id="IPv4客户与IPv6服务器"><a href="#IPv4客户与IPv6服务器" class="headerlink" title="IPv4客户与IPv6服务器"></a>IPv4客户与IPv6服务器</h3><p>其中的IPv6服务器主机是双栈主机。双栈主机的一个基本特性是其上的IPv6服务器既能处理IPv4客户，又能处理IPv6客户。这是通过使用IPv4映射的UPv6地址实现的。</p>
<ol>
<li>IPv6服务器启动后创建一个IPv6的监听套接字，假定服务器把通配地址绑定到该套接字上。</li>
<li>IPv4客户调用getaddrinfo函数获取IPv6服务器主机的信息。服务器既有A记录(IPv4类型的地址记录)又有AAAA记录(IPv6类型的地址记录)，但是IPv4客户只会用到查找到的A记录。</li>
<li>IPv4客户利用找到的服务器主机的A记录地址调用connect，发送IPv4 SYN到服务器主机。</li>
<li>服务器主机接收到这个目的地为IPv6监听套接字的IPv4 SYN，设置一个标志指示本连接应使用IPv4映射的IPv6地址，然后响应一个IPv4 SYN/ACK。该连接建立后，由accept返回给服务器的地址就是这个IPv4银蛇的IPv6地址。</li>
<li><p>以后客户主机和服务器主机都是通过IPv4数据报进行通信，底层由服务器主机的IP协议栈进行IPv4到IPv6地址映射转换。<br>可以看到上面的描述都是假设IPv6服务器必须是一个双栈主机：既有一个IPv4地址，又有一个IPv6地址。<br>大多数双栈主机在处理监听套接字时使用以下规则：</p>
</li>
<li><p>IPv4监听套接字只能接受来自IPv4客户的外来连接。</p>
</li>
<li>如果服务器有一个绑定了通配地址的IPv6监听套接字，而且该套接字未设置IPv6_V6ONLY套接字选项，那么该套接字既能接受来自IPv4客户的外来连接，又能接受来自IPv6客户的外来连接。</li>
<li>如果服务器有一个IPv6监听套接字，而且绑定在其上的是除IPv4映射的IPv6地址之外的某个非通配的IPv6地址，或者绑定在其上的是通配地址，不过还设置了IPv6_V6ONLY套接字选项，那么该套接字只能接受来自IPv6客户的外来连接。</li>
</ol>
<h3 id="IPv6客户与IPV4服务器"><a href="#IPv6客户与IPV4服务器" class="headerlink" title="IPv6客户与IPV4服务器"></a>IPv6客户与IPV4服务器</h3><p>对于这种情况，和上面的情况类似，只不过这里客户主机必须是双栈主机，而地址的转换也是在客户主机上IP协议栈负责的。</p>
</div></article></div></main><footer><div class="paginator"><a href="/2018/07/07/connect/" class="prev">PREV</a><a href="/2018/07/07/bigend/" class="next">NEXT</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'longxq-github-io';
var disqus_identifier = '2018/07/07/ipv4ipv6/';
var disqus_title = 'ipv4ipv6';
var disqus_url = 'https://longxq.github.io/2018/07/07/ipv4ipv6/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//longxq-github-io.disqus.com/count.js" async></script><div class="copyright"><p>© 2015 - 2018 <a href="https://longxq.github.io">龙雄球</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>